/*
Header file for defining a class for the USB-controlled FPGA waveform cards
*/
#pragma once

#include <vector> //needed for the vector of devices
#include <map> //needed for the waveform channel map
#include <string> // needed for parsing the device initalization list in fpgart.cpp from a defined list in 6733wvf.h
#include <sstream> // ditto
#include <wtypes.h> //needed for certain variable types in FTD2XX.H
#include "FTD2XX.H" // Header file for USB controls and types

#define USB_BYTE_RANGE 32767 // max number for positive values that the DAC will see
#define USB_MAX_VOLTAGE 10.0 // max voltage value taken
#define USB_DAC_UPDATE 0.02 // all times should be in micro-seconds
#define MIN_PDQ_TIME 0.24 // in micro-seconds, set by the time it takes to read in a cubic polynomial (12 clock cycles)
#define BRANCH_TOTAL 8 // the number of branch points available, set by VHDL code

#define MIN_VOLTAGE -10.0
#define MAX_VOLTAGE 10.0

// Some typedef's for the USB data vectors
typedef	std::vector<BYTE> USBWVF_data;
typedef std::map<unsigned, USBWVF_data> USBWVF_channel;
typedef std::map<unsigned, USBWVF_channel> USBWVF;

// Keeps data for branches of waveform data
static int ilistBranchLength[USB_CHAN_TOTAL][BRANCH_TOTAL]; // Give branch points, each with addresses for all PDQ channels

// This is the definition for the Class used for USB control of the USB-connected FPGA devices
class USB_WaveDev{
  public:
	// default constructor
	USB_WaveDev();

	FT_STATUS Open(); //Opens the device for accessing, sets ftHandle
	FT_STATUS Write(BYTE* wavePoint, DWORD size); //Writes a waveform to the device as a string of bytes
	FT_STATUS Close(); //Closes the device on shutdown

	//serial numbers are 8 characters followed by TWO nulls to give length 10
	char Serial[10]; //serial number of the device is stored here
	unsigned num_DACs; //the number of DACs on this USB device

  private:
	FT_HANDLE ftHandle; //the handle for the device
	DWORD written; //the write command uses this for how much data was sent
};

class USB_Waveform_Manager{
public:
	// Section of functions for accessing USB FT245RL communication commands

	// Ask the USB API to generate a list of FTDI devices
	static FT_STATUS CreateDeviceInfoList(DWORD * numDevs) {return FT_CreateDeviceInfoList(numDevs);};

	// Ask the USB API to retreive the list of FTDI devices and their information (generated by CreatDeviceInfoList)
	static FT_STATUS GetDeviceInfoList(FT_DEVICE_LIST_INFO_NODE * devInfo, DWORD * numDevs) {return FT_GetDeviceInfoList(devInfo, numDevs);};
	
	// get the index of FTDI device given a serial number (eg '2108DEV1')
	static int GetDeviceIndexFromSerialNumber(string * mySerialNo);
	
	// Sizes the device list based on the number of PDQ devices found
	static void ListSize(DWORD numPDQs) {USBWaveDevList.resize(numPDQs);};

	// Fills out a vector with an instance of a PDQ device and opens it
	static FT_STATUS InitSinglePDQMaster(DWORD devIndex, const char * serialNum, unsigned dacNum);

	// Close a device
	static FT_STATUS CloseDevice(DWORD devIndex) {return USBWaveDevList.at(devIndex).Close();};

	//Section of functions for handling Waveform data

	// Takes in the current waveform data, and parses it for a data vector that the FPGA understands
	//static bool WvfDownload(Cwvffrm * wvffrm);

	// Clear out the data in a channel or step, or clear it all
	static void WvfClear(int channel, int step);

	// Defines the device list, but isn't used until after the size is defined
	static std::vector<USB_WaveDev> USBWaveDevList;
	// Defines the waveform data map between a channel number and data to be sent there as a BYTE vector
	static USBWVF USBWvf;

//private:
	// Fill out the data in a waveform as bytes derived from vectors sent from a DC file
	static bool WvfFill(unsigned channel, unsigned step, int dataMode, 
		std::vector<double> vCurVals, std::vector<double> vTimeVals,
		std::vector<double> vdVVals, std::vector<double> vd2VVals, std::vector<double> vd3VVals);

	// Write a channel of data to a device
	static bool WvfWrite(unsigned channel, int dataMode);
};